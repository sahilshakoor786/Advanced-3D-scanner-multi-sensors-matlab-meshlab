Your scanner integrates five core mathematical components:

Triangulation-based IR ranging, where the Sharp GP2Y0A51SK0F outputs a voltage proportional to object distance via an internal triangulation method 
Sharp Global
.

Sonar-based ultrasonic ranging, using the standard distance = (speed of sound Ã— time)/2 formula 
Instructables
.

Polar-to-Cartesian conversion to turn angle + distance into (x,y,z) coordinates 
Stack Overflow
The blog at the bottom of the sea
.

Stepper motor angular resolution, achieved through full steps and optional microstepping for finer angular increments 
linearmotiontips.com
Anaheim Automation
.

Layer-by-layer slicing, lifting the sensor assembly by fixed increments and repeating sweeps to build a 3D point cloud 
ResearchGate
Creaform
.

Sensor Measurement Models
IR Sensor Triangulation
The Sharp GP2Y0A51SK0F employs an IR-LED, a position-sensitive detector (PSD), and onboard signal processing to perform triangulation: as the reflected spot moves on the PSD, the output voltage varies nonlinearly with distance 
Sharp Global
.
A cubic calibration curve (as in your code) maps output voltage to distance, capping at the sensorâ€™s maximum (~15 cm) for stability 
Pololu Robotics and Electronics
.

Ultrasonic Sonar Ranging
Each ultrasonic sensor emits a 40 kHz pulse and measures the round-trip time T of echoes; distance D is then

ğ·
=
1
2
â€‰
ğ‘‡
Ã—
ğ‘
,
D= 
2
1
â€‹
 TÃ—c,
where c â‰ˆ 343 m/s is the speed of sound 
Instructables
.
Your implementation uses a 10 Âµs trigger and pulseIn() with a timeout, converting microseconds to centimeters via

ğ·
(
cm
)
=
ğ‘‡
(
ğœ‡
ğ‘ 
)
Ã—
0.0343
2
D(cm)= 
2
T(Î¼s)Ã—0.0343
â€‹
 
and capping at your chosen maxDistance 
Medium
.

Coordinate Conversion
To reconstruct 3D geometry, each distance reading d at rotation angle Î¸ is converted from polar to Cartesian coordinates:

ğ‘¥
=
ğ‘‘
â€‰
sin
â¡
ğœƒ
,
ğ‘¦
=
ğ‘‘
â€‰
cos
â¡
ğœƒ
,
ğ‘§
=
layer
Ã—
Î”
ğ‘§
.
x=dsinÎ¸,y=dcosÎ¸,z=layerÃ—Î”z.
More generally, for full 3D spherical coordinates:

ğ‘¥
=
ğ‘Ÿ
sin
â¡
ğœ‘
â€‰
cos
â¡
ğ›¼
,
ğ‘¦
=
ğ‘Ÿ
sin
â¡
ğœ‘
â€‰
sin
â¡
ğ›¼
,
ğ‘§
=
ğ‘Ÿ
cos
â¡
ğœ‘
,
x=rsinÏ†cosÎ±,y=rsinÏ†sinÎ±,z=rcosÏ†,
where r is radius, Î± the horizontal angle, and Ï† the vertical angle 
Stack Overflow
The blog at the bottom of the sea
.

Stepper Motor Motion Control
Angular Resolution
Standard steppers have a full-step angle (commonly 1.8Â° per step for 200 steps/rev). Microstepping divides this furtherâ€”for example, 1/256 microsteps yields â‰ˆ 0.007Â° per microstep (i.e., 51,200 microsteps/rev) 
linearmotiontips.com
.

Speed vs. Precision
Your code uses two pulse routines:

rotateMotor() with 1 ms pulses (~500 Hz) for scanning, balancing speed and stability.

rotateMotorFast() with 0.2 ms pulses (~2,500 Hz) for initialization moves.
Angular displacement per pulse remains the same; only the stepping frequency changes 
Anaheim Automation
.

Layer-by-Layer Scanning Rationale
Slicing an object into horizontal layers is akin to rapid prototyping and tomography: each 2D contour (point cloud slice) captures object cross-sections at known z heights 
ResearchGate
.
By projecting sensor readings onto successive planesâ€”lifting Î”z per passâ€”you build up a full 3D model without complex surface fitting, directly stitching together contours from each layer 
ResearchGate
.

Through these mathematical and rational foundationsâ€”sensor calibration, geometric conversion, precise motor control, and systematic layeringâ€”your scanner reliably acquires a 3D point cloud of the scanned object.